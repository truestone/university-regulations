<context>
# Overview
대학 규정 관리 및 AI 검색 시스템은 동의대학교의 복잡한 규정 관리 체계를 현대화하고, AI 기반 자연어 검색을 통해 사용자가 원하는 정보를 쉽게 찾을 수 있도록 하는 웹 기반 시스템입니다.

**문제점:**
- 기존 74,707줄의 텍스트 파일 기반 규정 관리는 비효율적이고 오류 발생 가능성이 높음
- 사용자들이 복잡한 규정 구조에서 원하는 정보를 찾기 어려움
- 규정 변경 시 수동 관리로 인한 일관성 문제

**대상 사용자:**
- 관리자: 규정 CRUD 관리, 시스템 설정, 데이터 동기화
- 일반 사용자: 자연어 질문을 통한 규정 검색 및 답변 획득

**가치 제안:**
- 웹 기반 직관적인 규정 관리로 관리 효율성 50% 향상
- AI 기반 자연어 검색으로 정보 접근성 혁신
- 규정 변경 시 임베딩 자동 동기화로 데이터 일관성 보장

# Core Features

## 1. 규정 관리 시스템 (Admin)
**기능:** 웹 인터페이스를 통한 규정 CRUD 관리
- 편/장/규정/조/항/호 계층 구조 관리
- 별지/별표 첨부 파일 관리
- 규정 상태 관리 (활성, 폐지, 대체)
- 규정 개정 이력 추적

**중요성:** 기존 텍스트 파일 기반 관리를 체계적인 데이터베이스 관리로 전환
**구현:** Rails Admin 인터페이스 + 계층 구조 트리 뷰

## 2. AI 기반 자연어 검색
**기능:** 사용자 질문을 자연어로 입력하면 관련 규정 조항을 찾아 답변 제공
- 벡터 유사도 검색 (pgvector + OpenAI embeddings)
- 대화형 채팅 인터페이스
- 실시간 답변 생성 (Hotwire Turbo)
- 참조 규정 조항 링크 제공

**중요성:** 복잡한 규정 구조에서 원하는 정보를 쉽게 찾을 수 있는 혁신적 방법
**구현:** RAG 시스템 + OpenAI API + 벡터 검색

## 3. 임베딩 동기화 시스템
**기능:** 규정 변경 시 AI 검색 데이터(임베딩) 자동 업데이트
- 수동 동기화 (웹 인터페이스 + rake 명령)
- 배치 처리 최적화
- 동기화 진행 상황 추적

**중요성:** 규정 변경과 검색 데이터 간의 일관성 보장
**구현:** 백그라운드 작업 + 배치 처리 + 진행률 추적

## 4. 대화 세션 관리
**기능:** 익명 사용자의 대화 히스토리 관리
- 브라우저 세션 기반 대화 연속성
- 7일 자동 만료
- 대화 제목 자동 생성

**중요성:** 로그인 없이도 연속적인 대화 경험 제공
**구현:** 세션 기반 저장 + 자동 만료 정책

## 5. AI 설정 및 모니터링
**기능:** 다중 AI 제공업체 지원 및 사용량 관리
- OpenAI/Anthropic/Google API 설정
- 월 예산 한도 설정
- 실시간 사용량 모니터링
- 오류 추적 및 알림

**중요성:** 안정적인 AI 서비스 운영과 비용 관리
**구현:** 설정 관리 + 모니터링 대시보드

# User Experience

## User Personas

### 관리자 (Administrator)
- **역할:** 규정 관리, 시스템 설정, 데이터 동기화
- **목표:** 효율적인 규정 관리, 시스템 안정성 유지
- **페인포인트:** 복잡한 규정 구조 관리, 데이터 일관성 유지
- **사용 빈도:** 주 2-3회, 규정 변경 시

### 일반 사용자 (End User)
- **역할:** 규정 정보 검색 및 활용
- **목표:** 빠르고 정확한 규정 정보 획득
- **페인포인트:** 복잡한 규정 구조에서 원하는 정보 찾기 어려움
- **사용 빈도:** 필요 시 수시 이용

## Key User Flows

### 관리자 워크플로우
1. **로그인** → 관리자 대시보드 접근
2. **규정 관리** → 계층 구조 탐색 → 규정 CRUD
3. **임베딩 동기화** → 동기화 실행 → 진행 상황 확인
4. **AI 설정** → API 키 관리 → 예산 설정 → 사용량 모니터링

### 사용자 워크플로우
1. **검색 페이지 접근** → 자연어 질문 입력
2. **AI 답변 수신** → 참조 규정 확인 → 추가 질문
3. **대화 연속성** → 세션 기반 히스토리 유지

## UI/UX 고려사항

### 관리자 인터페이스
- **대시보드:** 시스템 상태, 최근 변경사항, 동기화 상태
- **규정 관리:** 트리 뷰 + 상세 편집 폼
- **설정 관리:** 탭 기반 설정 화면

### 사용자 인터페이스
- **검색:** 채팅 형태의 직관적 인터페이스
- **결과 표시:** AI 답변과 참조 문서 명확히 구분
- **반응형:** 모바일/태블릿/데스크톱 지원

### 대학 CI 적용
- 대학 로고 및 색상 체계
- Tailwind CSS 커스텀 컬러 팔레트
- 공식 서체 적용
</context>

<PRD>
# Technical Architecture

## System Components

### Frontend
- **Framework:** Rails Views + Tailwind CSS
- **Interactive:** Hotwire (Turbo) for real-time updates
- **Responsive:** Mobile-first design

### Backend
- **Framework:** Ruby on Rails 8.0.x
- **Database:** PostgreSQL with pgvector extension
- **Cache:** Redis for session and search result caching
- **Background Jobs:** Sidekiq for embedding synchronization

### AI Integration
- **Embedding:** OpenAI text-embedding-3-small (1536-dim)
- **LLM:** OpenAI GPT-4, Anthropic Claude, Google Gemini
- **Vector Search:** pgvector with cosine similarity
- **RAG System:** Custom implementation with context optimization

### Infrastructure
- **Development:** Docker-based environment (macOS → Linux containers)
- **Deployment:** Render.com (free tier)
- **Storage:** PostgreSQL + file system for attachments

## Data Models

### Core Models
1. **User:** Admin authentication and authorization
   - `email` (string, unique): 이메일 (로그인 ID)
   - `password_digest` (string): 암호화된 비밀번호
   - `name` (string): 관리자 이름
   - `role` (string): 역할 (admin, super_admin)
   - `last_login_at` (datetime): 마지막 로그인 시간

2. **Edition:** 규정집 편 (1-6편)
   - `number` (integer): 편 번호 (1-6)
   - `title` (string): 편 제목 (예: "학교법인", "학칙")
   - `description` (text): 편 설명
   - `sort_order` (integer): 정렬 순서
   - `is_active` (boolean): 활성 상태

3. **Chapter:** 규정집 장
   - `edition_id` (references): 소속 편
   - `number` (integer): 장 번호
   - `title` (string): 장 제목
   - `description` (text): 장 설명
   - `sort_order` (integer): 정렬 순서
   - `is_active` (boolean): 활성 상태

4. **Regulation:** 개별 규정 (3-1-65 형태 코드)
   - `chapter_id` (references): 소속 장
   - `number` (integer): 규정 번호 (편-장-규정 중 규정 부분)
   - `code` (string): 완전한 규정 코드 (예: "3-1-65")
   - `title` (string): 규정 제목
   - `status` (string): 상태 (active, abolished, superseded)
   - `abolished_at` (datetime): 폐지 일자
   - `superseded_by_id` (references): 대체 규정 ID
   - `enacted_at` (date): 제정 일자
   - `last_amended_at` (date): 최종 개정 일자
   - `department` (string): 소관 부서
   - `sort_order` (integer): 정렬 순서

5. **Article:** 규정의 조 (임베딩 저장)
   - `regulation_id` (references): 소속 규정
   - `number` (string): 조 번호 (예: "제1조", "제15조의2")
   - `title` (string): 조 제목
   - `content` (text): 조 내용 (전체 텍스트)
   - `embedding` (vector): 1536차원 벡터 임베딩
   - `embedding_updated_at` (datetime): 임베딩 업데이트 시간
   - `sort_order` (integer): 정렬 순서

6. **Clause:** 조의 항/호
   - `article_id` (references): 소속 조
   - `type` (string): 유형 (paragraph, item, subitem)
   - `number` (string): 항/호 번호 (예: "①", "1.", "가.")
   - `content` (text): 내용
   - `sort_order` (integer): 정렬 순서

7. **Attachment:** 별표/별지
   - `regulation_id` (references): 소속 규정
   - `type` (string): 유형 (table, form, appendix)
   - `number` (string): 별표/별지 번호
   - `title` (string): 제목
   - `content` (text): 내용
   - `file_path` (string): 파일 경로 (이미지/PDF인 경우)

8. **RegulationHistory:** 규정 개정 이력
   - `regulation_id` (references): 규정 ID
   - `version` (integer): 버전 번호
   - `amendment_date` (date): 개정 일자
   - `amendment_reason` (text): 개정 사유
   - `amended_by` (string): 개정 기관/부서

### Search Models
9. **Conversation:** 대화 세션
   - `session_id` (string, unique): 브라우저 세션 ID (UUID)
   - `title` (string): 대화 제목 (첫 질문 기반 자동 생성)
   - `created_at` (datetime): 생성 시간
   - `expires_at` (datetime): 만료 시간 (7일 후)
   - `last_message_at` (datetime): 마지막 메시지 시간
   - `message_count` (integer): 메시지 수

10. **Message:** 질문/답변 메시지
    - `conversation_id` (references): 대화 세션
    - `role` (string): 역할 ('user' 또는 'assistant')
    - `content` (text): 메시지 내용
    - `sources` (json): 참조된 규정 조항 정보
    - `processing_time` (float): AI 처리 시간 (초)
    - `tokens_used` (integer): 사용된 토큰 수
    - `created_at` (datetime): 생성 시간

11. **AiSetting:** AI 설정 및 API 키
    - `provider` (string): AI 제공업체 (openai, anthropic, google)
    - `model_name` (string): 모델 명
    - `api_key_encrypted` (text): 암호화된 API 키
    - `monthly_budget` (decimal): 월 예산 한도
    - `current_usage` (decimal): 현재 월 사용량
    - `is_active` (boolean): 활성 상태
    - `environment` (string): 환경 (development, production)

12. **SystemLog:** 시스템 로그
    - `action` (string): 수행 작업
    - `user_id` (references): 수행 사용자
    - `target_type` (string): 대상 모델
    - `target_id` (integer): 대상 ID
    - `details` (json): 상세 정보
    - `ip_address` (string): IP 주소
    - `created_at` (datetime): 실행 시간

### Database Schema
- **계층 구조:** Edition → Chapter → Regulation → Article → Clause
- **벡터 저장:** Article 테이블에 1536차원 임베딩
- **인덱스:** 벡터 검색 최적화 (ivfflat), 텍스트 검색 (GIN)

## APIs and Integrations

### External APIs
- **OpenAI API:** 임베딩 생성 및 텍스트 생성
- **Anthropic Claude API:** 대체 LLM 옵션
- **Google Gemini API:** 다중 제공업체 지원

### Internal APIs
- **Admin API:** 규정 CRUD 관리
- **Search API:** 벡터 검색 및 RAG 처리
- **Embedding API:** 임베딩 생성 및 동기화
- **Monitoring API:** 사용량 추적 및 상태 모니터링

## Infrastructure Requirements

### Development Environment
- **macOS Host:** Docker Desktop ONLY (완전한 Docker 기반 개발)
- **원칙:** macOS에 Rails, PostgreSQL, Redis, pgvector 등 직접 설치 금지
- **Containers:** Ruby 3.3, PostgreSQL with pgvector, Redis
- **워크플로우:** 모든 개발 작업은 컨테이너 내에서 수행

### Production Environment
- **Hosting:** Render.com (Linux)
- **Database:** PostgreSQL with pgvector extension
- **Caching:** Redis instance
- **SSL:** Let's Encrypt automatic setup

### Required Dependencies
**Essential Gems:**
- `pg`, `pgvector` - PostgreSQL 벡터 확장
- `ruby-openai` - OpenAI API 연동
- `anthropic` - Anthropic Claude API 연동
- `googleauth`, `google-apis-aiplatform_v1` - Google Gemini API 연동
- `redis` - 캐싱 및 세션 관리
- `tailwindcss-rails` - CSS 프레임워크
- `turbo-rails` - 실시간 업데이트
- `sidekiq` - 백그라운드 작업

# Development Roadmap

## Phase 1: Foundation & Core Infrastructure (MVP)
**Goal:** 기본 시스템 구조와 데이터 모델 구축

### 1.1 환경 설정 및 기본 구조
- Docker 개발 환경 구성
- Rails 8.0 프로젝트 생성
- PostgreSQL + pgvector 설정
- 기본 Tailwind CSS 설정

### 1.2 데이터 모델 구축
- Core 모델 생성 (User, Edition, Chapter, Regulation, Article, Clause)
- 데이터베이스 마이그레이션
- 모델 관계 설정 및 검증
- 기본 시드 데이터 생성

### 1.3 관리자 인증 시스템
- 관리자 로그인/로그아웃
- 기본 권한 관리
- 세션 관리

### 1.4 기본 Admin 인터페이스
- 관리자 대시보드
- 규정 목록 조회
- 기본 CRUD 인터페이스

## Phase 2: 데이터 임포트 및 파싱 시스템
**Goal:** 기존 텍스트 파일을 구조화된 데이터로 변환

### 2.1 텍스트 파싱 시스템
- 규정 텍스트 파일 분석
- 구조 식별 패턴 구현
- 파싱 규칙 정의 및 테스트

### 2.2 AI 기반 구조화 파싱
- OpenAI API 연동
- 구조화 파싱 프롬프트 엔지니어링
- 파싱 결과 검증 시스템
- 95% 이상 정확도 목표

### 2.3 데이터 임포트 시스템
- 배치 처리 최적화
- 데이터 검증 및 무결성 체크
- 오류 처리 및 재시도 로직
- JSON 중간 파일 생성

### 2.4 데이터 품질 관리
- 파싱 결과 미리보기
- 수동 검토 인터페이스
- 품질 메트릭 대시보드
- 오류 신고 시스템

### 2.5 데이터베이스 임포트
- 트랜잭션 기반 배치 처리
- 외래키 제약조건 설정
- 인덱스 최적화
- 중복 데이터 처리

### 2.6 임베딩 생성
- 벡터 임베딩 배치 처리
- OpenAI text-embedding-3-small 사용
- 조 단위 임베딩 생성
- 컨텍스트 보강 (규정/장/편 정보 포함)
- 진행률 추적 시스템

## Phase 3: AI 검색 시스템 구축
**Goal:** 벡터 검색 및 RAG 시스템 구현

### 3.1 임베딩 시스템
- 임베딩 생성 배치 처리
- 임베딩 저장 및 관리
- 동기화 시스템 구현

### 3.2 벡터 검색 엔진
- pgvector 인덱스 최적화
- 유사도 검색 알고리즘
- 검색 결과 랭킹 시스템

### 3.3 RAG 시스템
- 컨텍스트 구성 최적화
- 프롬프트 엔지니어링
- 답변 생성 시스템

### 3.4 검색 인터페이스
- 기본 검색 폼
- 검색 결과 표시
- 임시 답변 시스템

## Phase 4: 사용자 인터페이스 완성
**Goal:** 완전한 사용자 경험 구현

### 4.1 대화형 검색 인터페이스
- 채팅 형태 UI 구현
- 실시간 답변 표시 (Hotwire Turbo)
- 대화 히스토리 관리

### 4.2 세션 관리 시스템
- 익명 사용자 세션 관리
- 대화 연속성 구현
- 자동 만료 정책

### 4.3 고급 검색 기능
- 참조 규정 링크 제공
- 검색 결과 필터링
- 검색 히스토리

### 4.4 반응형 디자인
- 모바일 최적화
- 태블릿 지원
- 접근성 개선

## Phase 5: 고급 관리 기능
**Goal:** 완전한 관리자 기능 구현

### 5.1 고급 규정 관리
- 계층 구조 트리 뷰
- 드래그 앤 드롭 재정렬
- 벌크 편집 기능

### 5.2 AI 설정 관리
- 다중 AI 제공업체 지원
- API 키 관리
- 모델 선택 및 파라미터 조정

### 5.3 모니터링 및 알림
- 사용량 모니터링 대시보드
- 예산 한도 관리
- 오류 알림 시스템

### 5.4 시스템 로깅
- 사용자 행동 추적
- 시스템 성능 모니터링
- 감사 로그 관리

## Phase 6: 최적화 및 확장
**Goal:** 성능 최적화 및 확장성 확보

### 6.1 성능 최적화
- 데이터베이스 쿼리 최적화
- 캐싱 전략 구현
- 응답 시간 개선

### 6.2 확장성 준비
- 다중 대학 지원 구조
- API 확장 가능성
- 모바일 앱 지원 준비

### 6.3 보안 강화
- 보안 감사
- 데이터 보호 강화
- 접근 제어 개선

### 6.4 사용자 경험 개선
- 대학 CI 완전 적용
- 사용자 피드백 반영
- 성능 메트릭 기반 개선

# Logical Dependency Chain

## Foundation First (Phase 1)
**핵심 의존성:** 모든 기능의 기반이 되는 인프라
1. **Docker 환경 구성** → 모든 개발 작업의 전제조건
2. **데이터 모델 구축** → 모든 기능의 데이터 구조 기반
3. **관리자 인증** → 관리 기능 접근 제어
4. **기본 Admin UI** → 데이터 확인 및 관리 가능

## Data Pipeline (Phase 2)
**의존성:** Phase 1 완료 후 데이터 준비
1. **텍스트 파싱** → 데이터 구조화의 시작점
2. **AI 파싱** → 파싱 정확도 향상
3. **데이터 임포트** → 구조화된 데이터 저장
4. **품질 관리** → 데이터 신뢰성 확보

## AI System (Phase 3)
**의존성:** Phase 2 완료 후 AI 기능 구현
1. **임베딩 시스템** → 벡터 검색의 기반
2. **벡터 검색** → 유사도 기반 검색
3. **RAG 시스템** → 답변 생성의 핵심
4. **기본 검색 UI** → 사용자 접점 제공

## User Experience (Phase 4)
**의존성:** Phase 3 완료 후 사용자 경험 완성
1. **대화형 UI** → 핵심 사용자 경험
2. **세션 관리** → 연속 대화 지원
3. **고급 검색** → 사용자 편의성 향상
4. **반응형 디자인** → 다양한 디바이스 지원

## Advanced Features (Phase 5)
**의존성:** Phase 4 완료 후 고급 기능 추가
1. **고급 관리** → 관리자 생산성 향상
2. **AI 설정** → 유연한 AI 운영
3. **모니터링** → 시스템 안정성 확보
4. **로깅** → 운영 투명성 확보

## Optimization (Phase 6)
**의존성:** Phase 5 완료 후 최적화 및 확장
1. **성능 최적화** → 사용자 경험 개선
2. **확장성** → 미래 성장 대비
3. **보안** → 운영 안정성 확보
4. **UX 개선** → 사용자 만족도 향상

## Getting to Usable Frontend Quickly
**전략:** 최소 기능으로 빠른 가시적 결과 달성

### Sprint 1-2: 기본 구조 (2주)
- Docker 환경 + Rails 기본 설정
- 기본 데이터 모델 + 시드 데이터
- 관리자 로그인 + 기본 대시보드
- **결과:** 관리자가 로그인하여 데이터를 볼 수 있는 상태

### Sprint 3-4: 데이터 임포트 (2주)
- 기본 텍스트 파싱 + 샘플 데이터 임포트
- 규정 목록 조회 + 기본 CRUD
- **결과:** 실제 규정 데이터를 웹에서 관리할 수 있는 상태

### Sprint 5-6: 기본 검색 (2주)
- 임베딩 생성 + 벡터 검색
- 기본 검색 폼 + 검색 결과 표시
- **결과:** 사용자가 검색을 통해 답변을 받을 수 있는 상태

### Sprint 7-8: 대화형 UI (2주)
- 채팅 형태 인터페이스
- 실시간 답변 표시
- **결과:** 완전한 사용자 경험을 제공하는 MVP 완성

## Atomic Feature Development
**원칙:** 각 기능을 독립적으로 개발하되 점진적 개선 가능

### 데이터 모델 → 기본 CRUD → 고급 기능
1. **User 모델** → 로그인/로그아웃 → 권한 관리
2. **Regulation 모델** → 목록/상세 조회 → 계층 구조 관리
3. **Article 모델** → 내용 표시 → 임베딩 저장
4. **Search 기능** → 기본 검색 → 벡터 검색 → RAG 시스템

### 독립적 개발 가능한 컴포넌트
- **파싱 시스템:** 별도 서비스로 개발 가능
- **임베딩 시스템:** 백그라운드 작업으로 분리
- **검색 인터페이스:** 프론트엔드 독립 개발
- **관리자 인터페이스:** 별도 네임스페이스로 분리

# Risks and Mitigations

## Technical Challenges

### 1. 대용량 텍스트 파싱 정확도
**위험:** 74,707줄 텍스트 파일의 복잡한 구조로 인한 파싱 오류
**완화 방안:**
- AI 기반 파싱으로 95% 이상 정확도 목표
- 수동 검토 인터페이스 제공
- 점진적 개선 가능한 파싱 규칙 구조
- 파싱 결과 검증 시스템 구축

### 2. pgvector 크로스 플랫폼 호환성
**위험:** macOS 개발환경과 Linux 배포환경의 차이로 인한 호환성 문제
**완화 방안:**
- 완전한 Docker 기반 개발환경 구성
- macOS에 직접 라이브러리 설치 금지
- ankane/pgvector 이미지 사용
- 개발/배포 환경 100% 일치

### 3. AI API 비용 및 안정성
**위험:** AI API 사용량 급증으로 인한 예산 초과 및 서비스 중단
**완화 방안:**
- 월 예산 한도 설정 및 실시간 모니터링
- 다중 AI 제공업체 지원으로 백업 옵션 확보
- 캐싱 전략으로 중복 API 호출 방지
- 사용량 알림 시스템 구축

### 4. 벡터 검색 성능
**위험:** 대량 데이터에서 벡터 검색 성능 저하
**완화 방안:**
- 적절한 인덱스 설정 (ivfflat)
- 검색 결과 캐싱
- 배치 처리 최적화
- 성능 모니터링 및 튜닝

## MVP Scope and Build Strategy

### MVP 핵심 기능 정의
**포함 (Must Have):**
- 관리자 인증 및 기본 규정 관리
- 텍스트 파일 임포트 및 구조화 (최소 샘플 데이터)
- 기본 벡터 검색 및 AI 답변 생성
- 간단한 검색 인터페이스
- Docker 기반 개발 환경

**제외 (Nice to Have):**
- 고급 관리 기능 (드래그 앤 드롭, 벌크 편집)
- 다중 AI 제공업체 지원 (초기에는 OpenAI만)
- 고급 모니터링 및 알림
- 완전한 반응형 디자인
- 별표/별지 첨부 파일 관리

### 빠른 MVP 달성 전략
**8주 MVP 로드맵:**
- **Week 1-2:** Docker 환경 + 기본 데이터 모델 + 관리자 인증
- **Week 3-4:** 텍스트 파싱 + 샘플 데이터 임포트 + 기본 CRUD
- **Week 5-6:** 임베딩 생성 + 벡터 검색 + 기본 검색 폼
- **Week 7-8:** 채팅 UI + 실시간 답변 + 세션 관리

### 점진적 개선 전략
1. **기본 기능 우선:** 핵심 기능부터 구현
2. **사용자 피드백 반영:** 실제 사용 후 개선점 파악
3. **성능 최적화:** 사용 패턴 분석 후 최적화
4. **기능 확장:** 안정성 확보 후 고급 기능 추가

## Resource Constraints

### 개발 리소스
**제약:** 1인 개발자, 제한된 시간
**완화 방안:**
- 명확한 우선순위 설정
- 오픈소스 라이브러리 최대 활용
- 단순하고 검증된 기술 스택 사용
- 자동화 도구 활용

### 인프라 비용
**제약:** 무료 호스팅 계층의 제한사항
**완화 방안:**
- Render 무료 티어 활용
- Cold Start 방지 전략
- 효율적인 리소스 사용
- 비용 모니터링 시스템

### AI API 비용
**제약:** 월 예산 한도 내에서 운영
**완화 방안:**
- 효율적인 프롬프트 엔지니어링
- 중복 요청 방지 캐싱
- 배치 처리로 비용 최적화
- 사용량 기반 서비스 제한

## Data Quality and Consistency

### 파싱 품질 관리
**위험:** 부정확한 파싱으로 인한 잘못된 답변
**완화 방안:**
- 파싱 결과 검증 시스템
- 수동 검토 프로세스
- 품질 메트릭 추적
- 오류 신고 시스템

### 데이터 동기화
**위험:** 규정 변경과 임베딩 불일치
**완화 방안:**
- 변경 감지 시스템
- 자동 동기화 트리거
- 수동 동기화 옵션
- 동기화 상태 모니터링

## Data Import and Conversion Strategy

### Original Data Analysis
**동의대학교 규정집 특성:**
- **총 규모:** 74,707줄의 대용량 텍스트 파일
- **계층 구조:** 6편 → 다수 장 → 다수 규정 → 조 → 항/호
- **번호 체계:** X-Y-Z 형태 (편-장-규정)
- **특수 표기:** 폐지 규정 【폐지】 마킹
- **복합 문서:** 본문 + 별표 + 서식 혼재
- **한글 처리:** 조항 번호의 한글 표기 (제1조, ①, 가. 등)

### Data Quality Challenges
**예상 파싱 문제점:**
1. **번호 체계 불일치:** "3-1-65A", "3-1-65-1" 등 예외적인 번호 체계
2. **폐지 규정 처리:** 【폐지】 표시된 규정의 이력 관리
3. **복합 문서 구조:** 규정 본문, 별표, 서식이 혼재된 구조
4. **한글 조항 번호:** "제1조의2", "①", "가." 등 다양한 번호 형식

**해결 방안:**
- 정규표현식 패턴 확장 및 예외 규칙 정의
- `status` 필드로 상태 관리, `abolished_at` 날짜 기록
- 문서 타입별 분리 파싱 및 연결 관계 매핑
- 한글 번호 체계 정규화 함수 구현

### Cross-Platform Development Considerations

#### macOS Development Environment Constraints
**macOS와 Linux 환경 차이점:**
- **네이티브 확장 모듈:** pgvector 같은 네이티브 확장은 OS별로 설치 방법과 바이너리가 다름
- **성능 특성:** 동일 코드도 OS별로 성능 특성이 달라질 수 있음
- **파일 시스템:** 대소문자 구분 차이 (macOS는 기본적으로 대소문자 구분 없음)
- **시스템 명령어:** 쉘 스크립트 및 시스템 명령어 차이

#### Docker 필수 사용 이유
**macOS에서 직접 설치의 문제점:**
- **호환성 이슈:** macOS에 설치된 라이브러리는 Linux 배포 환경과 다름
- **의존성 충돌:** macOS 버전의 PostgreSQL, Redis 등이 배포 환경과 버전 차이 발생
- **테스트 신뢰성:** 개발 환경에서 정상 작동해도 배포 환경에서 실패할 수 있음

**완화 방안:**
- **완전한 Docker 기반 개발환경 구성**
- **macOS에 직접 라이브러리 설치 금지**
- **ankane/pgvector 이미지 사용**
- **개발/배포 환경 100% 일치**

### macOS 개발 환경 구성 원칙
**설치 금지 목록 (macOS 직접 설치 금지):**
- Ruby (rbenv, rvm 등)
- Rails
- PostgreSQL  
- Redis
- Node.js (프로젝트 내 필요한 경우)
- pgvector
- 기타 개발 관련 라이브러리

**허용 목록 (macOS 설치 허용):**
- Docker Desktop
- VS Code 또는 기타 에디터
- Git
- 터미널 앱

**개발 워크플로우:**
```bash
# 프로젝트 시작
docker-compose up -d

# Rails 서버 접속
docker-compose exec web bash

# 컨테이너 내에서 모든 Rails 명령 실행
docker-compose exec web rails console
docker-compose exec web rails db:migrate
docker-compose exec web bundle install
```

### 환경 변수 설정
```bash
# .env 파일 예시
DATABASE_URL=postgres://postgres:password@db:5432/regulations_development
REDIS_URL=redis://redis:6379/1
OPENAI_API_KEY=your_api_key_here
DOCKER_ENV=true  # pgvector 호환성 확인용
```
</PRD>
